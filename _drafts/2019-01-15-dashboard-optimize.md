# 仪表盘场景前端优化经验谈

相信绝大部分公司的中台系统中都存在仪表盘页面，以 [Ant Design Pro](https://pro.ant.design/index-cn) 提供的中台方案分析页面为例，通常仪表盘页面的形式如下。仪表盘由不同的图表卡片组成，并且在创建或者编辑时允许作者添加、删除卡片，拖拽卡片的位置和调整卡片的大小等等：

![](./images/dashboard-optimize/dashboard_sample.png)

图表卡片支持多种类型的图表展现，除了传统的折线图与柱状图外，还支持桑吉图、漏斗图甚至表格等等，以满足产品和运营同学以不同的角度洞察指标的变化的需求。但是无论卡片的展现形式有多么的千变万化，背后都需要后端精确的数据的予以支撑。

考虑到卡片是仪表盘的最小单元，彼此之间相互独立，并且可以被动态的添加、预览。所以在产品的设计阶段，我们将仪表盘信息分开存在在两个实体中：「仪表盘」和「卡片」。仪表盘只存储它拥有的卡片的基本信息，卡片的ID以及位置和尺寸。而卡片的详细信息以及查询工作则交给卡片独立获取，这样更加灵活。前端与后端同学约定接口时也是以卡片为中心，我们为卡片准备了两类接口, 为了便于描述，我们将接口简化和语义化：

1. `/meta`: 用于请求卡片的元信息，例如指标、维度、图表类型等
2. `/query`: 根据卡片的元信息查询图表数据，数据返回之后再进行渲染

之所以要将查询接口与元信息接口拆分开，是因为查询 payload 中除了元信息以外还要整合诸如全局的日期，筛选条件等额外信息

基于上述的设计，前端在实现阶段也非常简单，我们采取了一种「自治」（或者说是「懒惰」）的思想：仪表盘组件只负责将卡片组件实例以指定尺寸摆放在指定的位置，而至于这张卡片的加载、查询、渲染全权由卡片自己负责。基于这个思路，我们甚至不需要复杂的状态管理框架（如 Redux 或者 Mobx），仅仅依靠视图层的 React 就能够实现。卡片组件的实现借助了 [react-refetch](https://github.com/heroku/react-refetch) 类库，它以高阶组件的形式为数据加载提供便利，伪代码如下：

```javascript
// CardComponent.js:
import {connect} from 'react-refetch'

@connect(() => {
  return {
    metaInfoFetch {
      url: '/meta',
      andThen = () => ({
        query: '/query'
      })
    }
  }
})
class Card {
  render() {
    const queryResult = this.props.query.value
    return <Chart data={queryResult} />
  }
}

// DashboardComponent.js:
class Dashboard {
  return (
    <div>
      {cards.map(({id, position, size}) => 
        <Card id={id} position={position} size={size} />
      )}
    </div>
  )
}
```

**但是没想到前端这种「自治」的解决方案却给产品带来了灾难**

产品上线之后，我们得到用户反馈说某些仪表盘页面打开总时是会进入了「卡死」状态，即页面无法滚动，无法点击，甚至浏览器也无响应。即使没有「卡死」，一段时间内页面的交互反馈也会出现滞后的情况。我们整理出这些有问题的仪表盘之后，发现这些仪表盘都具有一些相似的特征：1) 卡片数量多 2) 卡片需要渲染的数据量大

因为允许用户随意的任意的配置卡片，所以某些仪表盘的卡片数量可以达到 20 甚至 30 张以上，而平均每张卡片需要发出两个网络请求，所以在打开仪表盘的瞬间同时有 40 个以上的请求发出，这显然是超出浏览器的处理能力的，同时浏览器也不允许同一个域下有这么的多并行请求，于是大部分的请求处于队列等待中；随着多个卡片查询结果的返回，这些卡片进入图表渲染阶段，而如果卡片是分钟级别的折线图的话，考虑到按照 n 个维度拆分的情况，图表需要处理 24 × 60 × n 的数据需要处理，这对性能的损耗也是极大的。于是你看到在同一时间内，满负荷的请求发出，众多的卡片在渲染，再加上其他需要执行的脚本，CPU 自然就进入了满负荷的状态，因为「单线程」的缘故，浏览器也就无暇响应用户的输入，以及渲染页面

